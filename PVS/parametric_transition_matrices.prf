(parametric_transition_matrices
 (expr_judgement_TCC1 0
  (expr_judgement_TCC1-1 nil 3701284629 ("" (judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (state formal-nonempty-type-decl nil parametric_transition_matrices
     nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (variable formal-nonempty-type-decl nil
     parametric_transition_matrices nil)
    (rat_expr type-decl nil rational_expressions nil)
    (parametric_transition_row type-eq-decl nil
     parametric_transition_matrices nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (evaluation type-eq-decl nil rational_expressions nil)
    (pre_wf_evaluation const-decl "boolean"
     parametric_transition_matrices nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (eval_TCC1 0
  (eval_TCC1-1 nil 3701615311 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (state formal-nonempty-type-decl nil parametric_transition_matrices
     nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (variable formal-nonempty-type-decl nil
     parametric_transition_matrices nil)
    (rat_expr type-decl nil rational_expressions nil)
    (parametric_transition_row type-eq-decl nil
     parametric_transition_matrices nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (evaluation type-eq-decl nil rational_expressions nil)
    (pre_wf_evaluation const-decl "boolean"
     parametric_transition_matrices nil)
    (transition_row type-eq-decl nil transition_matrices nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (image const-decl "finite_set[V]" transition_matrices nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (restrict const-decl "R" restrict nil)
    (image const-decl "set[R]" function_image nil)
    (finite_image application-judgement "finite_set[R]"
     function_image_aux nil)
    (finite_restrict application-judgement "finite_set[S]"
     restrict_set_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (eval_TCC2 0
  (eval_TCC2-1 nil 3701615311 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (state formal-nonempty-type-decl nil parametric_transition_matrices
     nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (variable formal-nonempty-type-decl nil
     parametric_transition_matrices nil)
    (rat_expr type-decl nil rational_expressions nil)
    (transition_row type-eq-decl nil transition_matrices nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (parametric_transition_matrix type-eq-decl nil
     parametric_transition_matrices nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (evaluation type-eq-decl nil rational_expressions nil)
    (wf_evaluation const-decl "boolean" parametric_transition_matrices
     nil)
    (transition_matrix type-eq-decl nil transition_matrices nil)
    (is_finite const-decl "bool" finite_sets nil)
    (image const-decl "finite_set[V]" transition_matrices nil)
    (finite_restrict application-judgement "finite_set[S]"
     restrict_set_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pre_wf_evaluation const-decl "boolean"
     parametric_transition_matrices nil)
    (probability nonempty-type-eq-decl nil real_transition_matrices
     nil)
    (<= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (map const-decl "{rr: transition_row[K, V2] | dom(rr) = dom(r)}"
         transition_matrices_map nil)
    (eval const-decl "mapped_real_transition_row(r)"
          parametric_transition_matrices nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (restrict const-decl "R" restrict nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (sum const-decl "R" transition_matrices_sum nil)
    (is_stochastic_row? const-decl "boolean" real_transition_matrices
     nil)
    (wf_evaluation const-decl "boolean" parametric_transition_matrices
     nil)
    (image const-decl "finite_set[V]" transition_matrices nil)
    (image const-decl "set[R]" function_image nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (eval_TCC3 0
  (eval_TCC3-1 nil 3701615311 ("" (subtype-tcc) nil nil)
   ((wf_evaluation const-decl "boolean" parametric_transition_matrices
     nil)
    (evaluation type-eq-decl nil rational_expressions nil)
    (parametric_transition_matrix type-eq-decl nil
     parametric_transition_matrices nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (transition_row type-eq-decl nil transition_matrices nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (wf_evaluation const-decl "boolean" parametric_transition_matrices
     nil)
    (eval const-decl "mapped_real_transition_row(r)"
          parametric_transition_matrices nil)
    (pre_wf_evaluation const-decl "boolean"
     parametric_transition_matrices nil)
    (finite_restrict application-judgement "finite_set[S]"
     restrict_set_props nil)
    (restrict const-decl "R" restrict nil)
    (probability nonempty-type-eq-decl nil real_transition_matrices
     nil)
    (<= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (rat_expr type-decl nil rational_expressions nil)
    (variable formal-nonempty-type-decl nil
     parametric_transition_matrices nil)
    (state formal-nonempty-type-decl nil parametric_transition_matrices
     nil)
    (map const-decl "{rr: transition_row[K, V2] | dom(rr) = dom(r)}"
         transition_matrices_map nil)
    (map const-decl "{mm: transition_matrix[K, V2] | dom(mm) = dom(m)}"
         transition_matrices_map nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (sum const-decl "R" transition_matrices_sum nil)
    (is_stochastic_row? const-decl "boolean" real_transition_matrices
     nil)
    (is_stochastic_matrix? const-decl "boolean"
     real_transition_matrices nil))
   nil))
 (vars_TCC1 0
  (vars_TCC1-1 nil 3701615673
   ("" (skeep)
    (("" (typepred "image[state, rat_expr](r)")
      ((""
        (case "empty?({v: variable |
              EXISTS (e: (image[state, rat_expr](r))):
                vars[variable](e)(v)})")
        (("1" (rewrite "emptyset_is_empty?")
          (("1" (forward-chain "finite_emptyset[variable]")
            (("1" (rewrite -2 -1) nil nil)) nil))
          nil)
         ("2" (expand "empty?")
          (("2" (skeep) (("2" (postpone) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   nil nil))
 (vars_TCC2 0
  (vars_TCC2-1 nil 3701615777 ("" (subtype-tcc) nil nil) nil nil))
 (IMP_finite_sets_sum_TCC1 0
  (IMP_finite_sets_sum_TCC1-1 nil 3701710146
   ("" (assuming-tcc) nil nil)
   ((restrict const-decl "R" restrict nil)
    (identity? const-decl "bool" operator_defs nil))
   nil))
 (IMP_finite_sets_sum_TCC2 0
  (IMP_finite_sets_sum_TCC2-1 nil 3701710146
   ("" (assuming-tcc) nil nil)
   ((real_plus_real_is_real application-judgement "real" reals nil)
    (associative? const-decl "bool" operator_defs nil)
    (commutative? const-decl "bool" operator_defs nil)
    (restrict const-decl "R" restrict nil))
   nil))
 (row_of_zeros 0
  (row_of_zeros-1 nil 3701714424
   ("" (skolem * ("r" "S" "u") :skolem-typepreds? T)
    ((""
      (lemma "finite_set_induction_rest"
       ("P"
        "LAMBDA(S: finite_set[(dom(r))]): (FORALL (s: (S)): trans(r)(s) = const(0)) IMPLIES finite_sets_sum
          [(dom(r)), real, 0,
           restrict[[numfield, numfield], [real, real], numfield](+)].sum(S,  LAMBDA (s: (dom(r))): eval(trans(r)(s), u)) = 0"))
      (("1" (split -1)
        (("1" (inst? -1) nil nil) ("2" (grind) nil nil)
         ("3" (skeep 1 :preds? T)
          (("3" (split -2)
            (("1" (expand "sum" 2)
              (("1" (copy -3)
                (("1" (instantiate -1 "choose(SS)")
                  (("1" (rewrite-with-fnum -1 2)
                    (("1" (rewrite-with-fnum -1 2)
                      (("1" (expand "eval" 2)
                        (("1" (expand "restrict" 2)
                          (("1" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skeep 1)
              (("2" (copy -2)
                (("2" (instantiate -1 "s")
                  (("1" (propax) nil nil)
                   ("2" (typepred "s") (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (grind) nil nil) ("3" (grind) nil nil)
       ("4" (grind) nil nil))
      nil))
    nil)
   ((parametric_transition_row type-eq-decl nil
     parametric_transition_matrices nil)
    (rat_expr type-decl nil rational_expressions nil)
    (variable formal-nonempty-type-decl nil
     parametric_transition_matrices nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (state formal-nonempty-type-decl nil parametric_transition_matrices
     nil)
    (eval def-decl "real" rational_expressions nil)
    (evaluation type-eq-decl nil rational_expressions nil)
    (sum def-decl "R" finite_sets_sum "finite_sets/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (restrict const-decl "R" restrict nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (const adt-constructor-decl "[real -> (const?)]"
           rational_expressions nil)
    (const? adt-recognizer-decl "[rat_expr -> boolean]"
     rational_expressions nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (finite_set_induction_rest formula-decl nil finite_sets_inductions
     "finite_sets/")
    (identity? const-decl "bool" operator_defs nil)
    (commutative? const-decl "bool" operator_defs nil)
    (associative? const-decl "bool" operator_defs nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (rest const-decl "set" sets nil)
    (finite_restrict application-judgement "finite_set[S]"
     restrict_set_props nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (finite_remove application-judgement "finite_set" finite_sets nil)
    (finite_rest application-judgement "finite_set" finite_sets nil)
    (/= const-decl "boolean" notequal nil)
    (remove const-decl "set" sets nil)
    (injective? const-decl "bool" functions nil)
    (s skolem-const-decl "(rest(SS))" parametric_transition_matrices
     nil)
    (SS skolem-const-decl "non_empty_finite_set[(dom(r))]"
     parametric_transition_matrices nil)
    (r skolem-const-decl "parametric_transition_row"
     parametric_transition_matrices nil)
    (choose const-decl "(p)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil))
   shostak)))

